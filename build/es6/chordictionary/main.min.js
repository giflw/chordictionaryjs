/**Chordictionary v0.1.0-beta.3, @license MIT, (c) 2019 Hubert Fauconnier + contributors*/
import{WORDING}from"./wordings";import{NOTES}from"./notes";import*as INTERVAL from"./interval";import*as CHORD from"./chords";import*as TUNING from"./tuning";import*as TAB from"./tab";import*as TOOLS from"./tools";class Instrument{constructor(t,e,r,o){try{if(!TUNING.isValid(t))throw WORDING.invalidTuning;this.tuning=TUNING.parse(t),this.fretNumber=e,this.fretsToDisplay=isNaN(r)?0:r+1,this.maxSpan=isNaN(o)?4:o}catch(t){return console.error(t),!1}return this}getChordInfo(t){let e=[],r=[],o="",i=[],n={error:"",tab:[],notes:"",tuning:this.tuning,chords:[]};try{if(!TAB.isValid(t))throw WORDING.invalidTab;t=TAB.parse(t),n.tab=t}catch(t){return n.error=t,n}try{e=TAB.toNotes(t,this.tuning),n.notes=[...e]}catch(t){return n.error=WORDING.failedToConvertTabIntoNotes,n}try{r=TAB.getSemitones(e)}catch(t){return n.error=WORDING.failedToCalculateFormula,n}o=r.map(TAB.stripFormula);try{for(let t=0;t<o.length;t++){let e=CHORD.find(o[t]);e&&i.push({formula:e.formula,integer:e.integer,semitones:[...r][t],name:e.name,suffix:e.suffix})}if(!(i.length>0))throw WORDING.noMatch;{let t=CHORD.dedupMatches(i);i=i.filter((e,r)=>!t.includes(r))}}catch(t){return n.error=t,n}for(let t of i){var s=e[t.semitones.indexOf(0)];n.chords.push({name:s+t.suffix,pitch:s,formula:t.formula,intervals:INTERVAL.toDiatonic(t.semitones),semitones:t.semitones,notes:[...e],quality:t.name,suffix:t.suffix})}return n}getChordsList(t,e,r){r=r||0;let o,i,n,s,a=[],l=[],h={error:"",chordList:[],offset:0};const f={basic:{rootBelow4thFret:!0,noMuteAfterFirstNote:!0,rootIsLowestNote:!0,splittedChord:!1,openString:!0},powerchord:{frettedNotes:[2,3],rootIsLowestNote:!0,rootOnLowestFret:!0,splittedChord:!1,openString:!1},bar:{rootIsLowestNote:!0,rootOnLowestFret:!0,barredString:[3,6],noMuteAfterFirstNote:!0,splittedChord:!1,openString:!1}};try{if("string"!=typeof t)throw WORDING.invalidChordName;n=(t=CHORD.parse(t))[0],o=t[1],a.push(n),s=NOTES.indexOf(n),l=(i=TOOLS.searchInObject(CHORD.FORMULAS,o)).integer.split("-")}catch(t){return h.error=WORDING.invalidChordName,h}for(let t=1;t<l.length;t++){let e=parseInt(l[t])+parseInt(s);e>NOTES.length-1&&(e-=NOTES.length),a.push(NOTES[e])}let d,p=[],u=0;for(u=0;u<this.tuning.length;u++){p[u]=[],p[u].push("x");for(let t=0;t<a.length;t++)(d=NOTES.indexOf(a[t])-NOTES.indexOf(this.tuning[u]))<0&&(d=NOTES.length+d),p[u].push(d),d+12<this.fretNumber&&p[u].push(d+12)}let N=[];for(u=0;u<this.tuning.length;u++){let t=N.length;for(let e=0;e<p[u].length;e++)if(N[e])for(let r=0;r<t;r++)if(0===e)N[r].push(p[u][e]);else{let t=N[r].slice(0);t.pop(),t.push(p[u][e]),N.push(t)}else N[e]=[p[u][e]]}let g=[],c=(t,e)=>{for(let r in t){if(!Object.prototype.hasOwnProperty.call(e,r))return!1;if("object"==typeof t[r]){let o=t[r][0],i=t[r][1];if(e[r]<o||e[r]>i)return!1}else if(e[r]!==t[r])return!1}return!0};try{for(let t=r;t<N.length;t++){if(CHORD.isValid(N[t],a,this.tuning)&&TOOLS.arrayFind(N[t],"max")-TOOLS.arrayFind(N[t],"min")<this.maxSpan){let e={openString:!1,frettedNotes:0},r=N[t].join(""),o=/[0-9]+[x]+/gi;/[0-9]+[x]+[0-9]+/gi.test(r)?e.splittedChord=!0:e.splittedChord=!1,o.test(r)?e.noMuteAfterFirstNote=!1:e.noMuteAfterFirstNote=!0;for(let r=0;r<N[t].length;r++){let o=N[t][r];if(!isNaN(o)){let i=o+NOTES.indexOf(this.tuning[r]);0===o&&(e.openString=!0),s===i&&(0===e.frettedNotes&&(e.rootIsLowestNote=!0),e.rootBelow4thFret=o<=4,e.rootOnLowestFret=TOOLS.arrayFind(N[t],"min")>=o),(o>0&&r<N[t].length-1&&o===N[t][r-1]||TOOLS.arrayFind(N[t],o)>=3)&&(e.barredString=isNaN(e.barredString)?1:e.barredString+1),e.frettedNotes++}}let i={tab:N[t],tag:[]};Object.getOwnPropertyNames(f).forEach(t=>{c(f[t],e)&&i.tag.indexOf(t)&&i.tag.push(t)}),g.push(i)}if(e>0&&e<N[t].length&&g.length===e){r=t+1;break}}}catch(t){console.error(t)}return h.chordList=g,h.offset=r,h}getChordLayout(t,e){let r,o,i=this.fretsToDisplay;e="object"==typeof e?e:{};try{r=TAB.isValid(t)?TAB.parse(t):[0,0,0,0,0,0]}catch(t){return!1}let n=e.notes?e.notes:r,s=e.name?e.name:r.join(" "),a=[];for(let t=0;t<r.length;t++)!1===isNaN(r[t])&&a.push(r[t]);let l=Math.abs(Math.max.apply(Math,a)),h=Math.abs(Math.min.apply(Math,a)),f=1;l>=i&&(f=h>0?h:1),1===f&&l>5&&(f=l-i+2);try{if(0===i)i=l-f+2;else if(l-f+1>i-1)throw i=l-f+2,WORDING.croppedChordLayout}catch(t){console.error(t)}o='<table class="chord">';for(let t=0;t<i;t++){let e=t+f-1;1===f&&0===t&&(o+="<thead>"),o+=e%2&&e>0?'<tr><th class="fret-number">'+e+"</th>":"<tr><th></th>";for(let e=0;e<this.tuning.length;e++){let i=parseInt(r[e]);o+=0===t?0===i?'<th><div class="dot open"></div></th>':"<th></th>":i===f+t-1?'<td><div class="dot plain">'+n[e]+"</div></td>":"<td></td>"}o+=1===f&&0===t?"<tr></thead>":"</tr>"}return o+='<caption align="bottom">'+s+"</caption>",o+="</table>"}}const isValidTab=TAB.isValid,isValidTuning=TUNING.isValid,parseTuning=TUNING.parse,parseTab=TAB.parse,parseChord=CHORD.parse,tuning=TUNING.GET,notes=NOTES;export{Instrument,isValidTab,isValidTuning,parseTuning,parseTab,parseChord,tuning,notes};